--- INICIO ARCHIVO: C:\Users\Usr\Documents\MiniAgente\main.py ---
from src.core.scanner import obtener_datos_pc
from src.database.firebase_client import enviar_datos_pc
from config.config import VERSION, DEBUG_MODE
import time

def ejecutar_agente():
    # Mensaje de encabezado con versiÃ³n
    if DEBUG_MODE:
        print(f"\n--- ðŸ› ï¸ MODO DESARROLLO: Ejecutando Agente V.{VERSION} ---")
    else:
        print(f"\n--- Agente de Inventario V.{VERSION} ---")
    
    try:
        # Escaneo
        print("ðŸ” Escaneando hardware y usuarios...")
        datos_hardware = obtener_datos_pc()
        
        # Metadata (Agregamos la versiÃ³n tambiÃ©n a los datos que suben)
        datos_hardware["version_agente"] = VERSION
        datos_hardware["ultima_actualizacion"] = time.strftime("%Y-%m-%d %H:%M:%S")
        
        # SincronizaciÃ³n
        print(f"â˜ï¸  Sincronizando UUID: {datos_hardware['uuid']}...")
        enviar_datos_pc(datos_hardware)
        
        print("âœ… SincronizaciÃ³n finalizada.")
        
    except Exception as e:
        print(f"âŒ Error en la ejecuciÃ³n: {e}")

if __name__ == "__main__":
    ejecutar_agente()
--- FIN ARCHIVO ---


--- INICIO ARCHIVO: C:\Users\Usr\Documents\MiniAgente\config\config.py ---
import os

# 1. Detectar la carpeta donde estÃ¡ este archivo (MiniAgente/config)
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))

# 2. Subir un nivel para llegar a la raÃ­z (MiniAgente/)
BASE_DIR = os.path.dirname(CURRENT_DIR)

# 3. Apuntar correctamente a la carpeta 'auth'
FIREBASE_JSON_PATH = os.path.join(BASE_DIR, "auth", "serviceAccountKey.json")

# ConfiguraciÃ³n de Firebase
FIREBASE_COLLECTION_NAME = "computadoras"
VERSION = "1.0.0"
DEBUG_MODE = True
--- FIN ARCHIVO ---


--- INICIO ARCHIVO: C:\Users\Usr\Documents\MiniAgente\src\core\scanner.py ---
import psutil
import platform
import subprocess
import os
import requests

def obtener_id_anydesk():
    # Definimos todas las rutas posibles donde AnyDesk guarda su config
    posibles_rutas = [
        os.path.join(os.environ.get('ProgramData', 'C:\\ProgramData'), 'AnyDesk', 'system.conf'),
        os.path.join(os.environ.get('AppData', ''), 'AnyDesk', 'system.conf'),
        os.path.join(os.environ.get('LocalAppData', ''), 'AnyDesk', 'system.conf')
    ]
    
    for ruta in posibles_rutas:
        if os.path.exists(ruta):
            try:
                # Usamos 'rb' (read binary) y luego decodificamos para evitar errores de caracteres
                with open(ruta, 'rb') as f:
                    contenido = f.read().decode('utf-8', errors='ignore')
                    for linea in contenido.splitlines():
                        if 'ad.anydesk.id' in linea:
                            return linea.split('=')[1].strip()
            except PermissionError:
                return "Requiere Admin"
            except Exception:
                continue
                
    return "No detectado"

def obtener_ip_publica():
    """
    Intenta obtener la IP pÃºblica usando mÃºltiples servicios.
    Retorna la IP como string o un mensaje de error si falla todo.
    """
    # Lista de proveedores confiables (Redundancia)
    servidores_ip = [
        'https://api.ipify.org',
        'https://checkip.amazonaws.com',
        'https://ifconfig.me/ip'
    ]
    
    for url in servidores_ip:
        try:
            # timeout=5 es vital: si el sitio no responde en 5 seg, pasa al siguiente
            respuesta = requests.get(url, timeout=5)
            if respuesta.status_code == 200:
                # .strip() limpia espacios o saltos de lÃ­nea invisibles
                return respuesta.text.strip()
        except Exception:
            # Si hay error (sin internet o sitio caÃ­do), sigue con el prÃ³ximo
            continue
            
    return "IP no disponible (Sin conexiÃ³n)"

def obtener_aplicaciones_activas():
    apps = set()
    for proc in psutil.process_iter(['name']):
        try:
            nombre = proc.info['name']
            if nombre.lower().endswith('.exe'):
                if nombre.lower() not in ['svchost.exe', 'conhost.exe', 'idle']:
                    apps.add(nombre)
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue
    
    return sorted(list(apps))[:15] # Retorna las primeras 15 alfabÃ©ticamente

def obtener_usuarios():
    try:
        usuario_actual = os.getlogin()
        
        usuarios_activos = [u.name for u in psutil.users()]
        
        return {
            "usuario_actual": usuario_actual,
            "usuarios_activos": list(set(usuarios_activos))
        }
    except Exception:
        return {"usuario_actual": "Desconocido", "usuarios_activos": [] }

def obtener_id_inventario():
    try:
        cmd = 'wmic csproduct get uuid'
        resultado = subprocess.check_output(cmd, shell=True).decode().split('\n')
        uuid = resultado[1].strip()
        return uuid
    except Exception as e:
        print(f"Error obteniendo UUID: {e}")
        return platform.node()

def obtener_datos_pc():
    ip = obtener_ip_publica()
    anydesk_id = obtener_id_anydesk()
    
    datos = {
        "uuid": obtener_id_inventario(),
        "hostname": platform.node(),
        "sistema_operativo": f"{platform.system()} {platform.release()}",
        "arquitectura": platform.machine(),
        "ip_publica": ip,
        "anydesk_id": anydesk_id,
        "aplicaciones_activas": obtener_aplicaciones_activas(),
        "procesador": platform.processor(),
        "nucleos_fisicos": psutil.cpu_count(logical=False),
        "ram_total_gb": round(psutil.virtual_memory().total / (1024 ** 3), 2),
        "discos": [],
        "cpu_uso_porcentaje": psutil.cpu_percent(interval=1),
        "ram_uso_porcentaje": psutil.virtual_memory().percent,
    }
    
    datos["usuarios"] = obtener_usuarios()
    
    for partition in psutil.disk_partitions():
        if 'fixed' not in partition.opts:
            continue
            
        try:
            uso = psutil.disk_usage(partition.mountpoint)
            datos["discos"].append({
                "dispositivo": partition.device,
                "punto_montaje": partition.mountpoint,
                "total_gb": round(uso.total / (1024 ** 3), 2)
            })
        except PermissionError:
            continue
        
    return datos

if __name__ == "__main__":
    print("----- Escaneo de Datos de la PC -----")
    info = obtener_datos_pc()
    
    for clave, valor in info.items():
        if clave != "discos":
            print(f"{clave.replace('_', ' ').capitalize()}: {valor}")
    
    print("Discos detectados: {len(info['discos'])}")
    for d in info['discos']:
        print(f"  - Dispositivo: {d['dispositivo']}Total: {d['total_gb']} GB")
--- FIN ARCHIVO ---


--- INICIO ARCHIVO: C:\Users\Usr\Documents\MiniAgente\src\database\firebase_client.py ---
import firebase_admin
from firebase_admin import credentials, firestore
from config.config import FIREBASE_JSON_PATH, FIREBASE_COLLECTION_NAME # <--- Importamos la configuraciÃ³n

# Inicializamos la conexiÃ³n solo si no existe una previa
if not firebase_admin._apps:
    cred = credentials.Certificate(FIREBASE_JSON_PATH)
    firebase_admin.initialize_app(cred)

db = firestore.client()

def enviar_datos_pc(datos):
    try:
        document_id = datos.get("uuid")
        
        if not document_id:
            print("âŒ Error: Los datos no contienen un UUID. No se puede sincronizar.")
            return
        
        # Referencia a la colecciÃ³n definida en config.py
        doc_ref = db.collection(FIREBASE_COLLECTION_NAME).document(document_id)
        
        # CreaciÃ³n o actualizaciÃ³n del documento
        doc_ref.set(datos)
        
        print(f"âœ… Datos sincronizados correctamente en la nube. ID: {document_id}")
    except Exception as e:
        print(f"âŒ Error crÃ­tico al subir a Firebase: {e}")

if __name__ == "__main__":
    # Prueba rÃ¡pida corregida con un UUID ficticio
    prueba = {
        "uuid": "TEST-UUID-1234",
        "hostname": "TEST-PC",
        "status": "Conectado"
    }
    enviar_datos_pc(prueba)
--- FIN ARCHIVO ---


